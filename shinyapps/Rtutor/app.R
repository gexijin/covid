library(openai)
library(tidyverse)
library(shiny)

###################################################
# Global variables
###################################################

uploaded_data <- "Uploaded data" 
min_query_length <- 10  # minimum # of characters
max_query_length <- 500 # max # of characters

#' Move an element to the front of a vector
#'
#' The response from GPT3 sometimes contains strings that are not R commands.
#'
#' @param v is the vector
#' @param e is the element
#'
#' @return Returns a reordered vector
move_front <- function(v, e){
  ix <- which(v == e)

  # if found, move to the beginning.
  if(length(ix) != 0) {
    v <- v[-ix]
    v <- c(e, v)
  }
  return(v)
}


#' Prepare User input.
#'
#' The response from GPT3 sometimes contains strings that are not R commands.
#'
#' @param txt A string that stores the user input.
#' @param selected_data Name of the dataset.
#'
#' @return Returns a cleaned up version, so that it could be sent to GPT.
prep_input <- function(txt, selected_data){
  # if too short, do not send. 
  if(nchar(txt) < min_query_length || nchar(txt) > max_query_length) {
    return(NULL)
  }

  if(!is.null(selected_data)) {
    if(selected_data == uploaded_data) {
      selected_data <- "df"
    }
    txt <- paste("Use the", selected_data, "data frame. ", txt)
  }
  txt <- paste("Generate R code, not R Markdown. ", txt)

  # If the last character is not a stop, add it. 
  # Otherwise, GPT3 will add a sentence.

  # The following 5 lines were generated by ChatGPT!!!!!
  # Check if the last character is not a period
  if(substr(txt, nchar(txt), nchar(txt)) != ".") {
    # If the last character is not a period, add a period to the end of the string
    txt <- paste(txt, ".", sep = "")
  }

  return(txt)
}


#' Clean up R commands generated by GTP
#'
#' The response from GTP3 sometimes contains strings that are not R commands.
#'
#' @param cmd A string that stores the completion from GTP3.
#' @param selected_data, name of the selected dataset. 
#' @return Returns a cleaned up version, so that it could be executed as R command.
clean_cmd <- function(cmd, selected_data){
  # simple way to check
  if(grepl("That model is currently overloaded with other requests.|Error:", cmd)) {
    return(NULL)
  }
  # Use cat to converts \n to newline
  # use capture.output to get the string
  cmd <- capture.output(
    cat(cmd)
  )

  #cmd is a vector. Each element is a line.

  # sometimes it returns RMarkdown code.
  cmd <- gsub("```", "", cmd)

  # remove empty lines
  cmd <- cmd[cmd != ""]
  
  # replace install.packages by "#install.packages"
  cmd <- gsub("install.packages", "#install.packages", cmd)

  # if data is uploaded, add a line to get the data.
  if(selected_data == uploaded_data) {
    cmd <- c("df <- user_data()", cmd)
  }
  # Add try function. Not really doing anything, tho.
  cmd <- c("tryCatch({", cmd, "})")

  return(cmd)

}


###################################################################
# Prepare data
###################################################################
demos <- c(
  'Select an example request' = 'Example requests',
  Boxplot = "Use ggplot2 to create a boxplot of hwy vs. class. Color by class.",
  ANOVA = "Conduct ANOVA of hwy by class.",
  Boxplot2 = "Use ggplot2 to create a boxplot of hwy vs. class.  Color by class.
Add jitter.
Remove x label.",
  ANOVA2 = "Conduct ANOVA of log-transformed hwy by class and drv.",
  Scatter = "Plot hwy vs. cty, colored by class. Change shape by drv.",
  Barplot = "Calculate average cty by year and class.
Then use ggplot2 to create a barplot of average mpg by class,
colored by year. The years should be side by side.",
  Analysis = "Calculate the correlation of cty vs hwy.
Repeat that after log transformation.
Collect these results and show them.",
Analysis2 = "Only keep cars with hwy bigger than 15, but less than 40.
Add 0.5 to cty.
Perform log transformation on cty.
Raise hwy to the second power.
Calculate correlation coefficient of transformed hwy and cty.",
Analysis_complex = "hwy and cty represent miles per gallon (MPG) on the highway and in the city, respectively.
Only keep cars more efficient than 15 MPG, but less than 40, on the highway.
Add 0.5 to city MPG for correction.
Perform log transformation on city MPG.
Raise highway MPG to the second power.
Calculate correlation coefficient of  the two transformed variables.",
Neural_net = "Build a neural network model to predict 
hwy based on displ, cyl, and class.  
Use the nnet package. Plot the residules."
)

# prepare a list of available data sets.
datasets <- data()$results[, 3] # name of datasets
datasets <- gsub(" .*", "", datasets)
datasets <- move_front(datasets, "state.x77")
datasets <- move_front(datasets, "iris")
datasets <- move_front(datasets, "mtcars")
datasets <- move_front(datasets, "diamonds")
datasets <- move_front(datasets, "mpg")
datasets <- c(datasets, uploaded_data)


###################################################################
# UI
###################################################################

ui <- fluidPage(
  titlePanel("RTutor - Do statistics in English"),
  # Sidebar with a slider input for number of bins
  sidebarLayout(
    sidebarPanel(
        # Application title

      p(HTML("<div align=\"right\"> <A HREF=\"javascript:history.go(0)\">Reset</A></div>")),
      fluidRow(
        column(
          width = 5,
          uiOutput("demo_data_ui")
        ),
        column(
          width = 7,
          uiOutput("data_upload_ui")
        )
      ),

      uiOutput("prompt_ui"),

      tags$style(type = "text/css", "textarea {width:100%}"),
      tags$textarea(
        id = "input_text",
        placeholder = NULL,
        rows = 8, ""
      ),
      actionButton("submit_button", strong("Submit")),
      tags$head(tags$style(
        "#submit_button{font-size: 16px;color: red}"
      )),
      br(), br(),
      verbatimTextOutput("usage"),

      h5("Powered by  OpenAI's", 
        a("ChatGPT.", 
          href = "https://openai.com/blog/chatgpt/", 
          target = "_blank"
        ),
        " Personal project by",
        a("Xijin Ge.", href = "https://twitter.com/StevenXGe", target = "_blank"),
      "12/6/2022."
      ),
    ),

    # Show a plot of the generated distribution
    mainPanel(

    tabsetPanel(
      type = "tabs",
      tabPanel("Main",
        verbatimTextOutput("openAI"),
        br(), br(),
        uiOutput("results_ui"),
        br(), br(),
        tableOutput("data_table")
      ),

      tabPanel("Debug",
        verbatimTextOutput("prompt_ChatGPT"),
        verbatimTextOutput("R_cmd")
      )
    )

    )
  )
  ,tags$head(includeScript("ga.js")) # tracking usage with Google analytics
)


###################################################################
# Server
###################################################################

server <- function(input, output, session) {

  # load demo data when clicked
  observe({
    req(input$demo_prompt)
    req(input$select_data)
    if(input$select_data == "mpg" && input$demo_prompt != demos[1]) {
      updateTextInput(
        session,
        "input_text",
        value = input$demo_prompt
      )
    } else { # if not mpg data, reset
      updateTextInput(
        session,
        "input_text",
        value = "",
        placeholder =
"Clearly state the desired statistical analysis in plain English. See examples above.

If there is an error, try again with the same request.

The code is sometimes incorrect."
      )
    }
  })

  observeEvent(input$user_file, {
    updateSelectInput(
      session,
      "select_data",
      selected = uploaded_data
    )
  }, ignoreInit = TRUE, once = TRUE)

  observe({
    if (input$submit_button > 0) {
      updateTextInput(session, "submit_button", label = "Re-submit")
    }
  })

  user_data <- reactive({
    req(input$user_file)
    in_file <- input$user_file
    in_file <- in_file$datapath
    req(!is.null(in_file))

    isolate({
      # Excel file ---------------
      if(grepl("xls$|xlsx$", in_file, ignore.case = TRUE)) {
        df <- readxl::read_excel(in_file)
        df <- as.data.frame(df)
      } else {
        #CSV --------------------
        df <- read.csv(in_file)
        # Tab-delimented file ----------
        if (ncol(df) == 2) {
          df <- read.table(
            in_file,
            sep = "\t",
            header = TRUE
          )
        }
      }
      return(df)
    })
  })

  output$data_upload_ui <- renderUI({

    # Hide this input box after the first run.
    req(input$submit_button == 0)

    fileInput(
      inputId = "user_file",
      label = "Upload a CSV, TSV, or Excel file",
      accept = c(
        "text/csv",
        "text/comma-separated-values",
        "text/tab-separated-values",
        "text/plain",
        ".csv",
        ".tsv",
        ".txt",
        ".xls",
        ".xlsx"
      )
    )
  })

  output$demo_data_ui <- renderUI({

    # Hide this input box after the first run.
    req(input$submit_button == 0)

    selectInput(
      inputId = "select_data",
      label = "Dataset:",
      choices = datasets,
      selected = "mpg",
      multiple = FALSE,
      selectize = FALSE
    )

  })

  output$prompt_ui <- renderUI({

    req(input$select_data)

    # hide after data is uploaded
    req(is.null(input$user_file))

    if(input$select_data == "mpg") {
      selectInput(
        inputId = "demo_prompt",
        choices = demos,
        label = NULL
      )
    } else {
      return(NULL)
    }
  })

  openAI_response <- reactive({

    req(input$submit_button)
    req(input$select_data)

    isolate({  # so that it will not responde to text, until submitted
      req(input$input_text)
      prepared_request <- prep_input(input$input_text, input$select_data)
      req(prepared_request)

      withProgress(message = "Thinking ... (About 1 min)", value = 0, {
        incProgress(0.7)

        start_time <- Sys.time()
        # Send to openAI
        response <- create_completion(
          engine_id = "text-davinci-003",
          prompt = prepared_request,
          openai_api_key = Sys.getenv("OPEN_API_KEY"),
          max_tokens = 500
        )
        api_time <- difftime(
          Sys.time(),
          start_time,
          units = "secs"
        )[[1]]

        #issue: check status

        cmd <- clean_cmd(response$choices[1, 1], input$select_data)

        return(
          list(
            cmd = cmd,
            response = response,
            time = round(api_time, 0)
          )
        )
      })
    })
  })

  output$openAI <- renderText({
    req(openAI_response()$cmd)
    res <- openAI_response()$response$choices[1, 1]
    # Replace multiple newlines with just one.
    res <- gsub("\n+", "\n", res)
    # Replace emplty lines,  [ ]{0, }--> zero or more space
    res <- gsub("^[ ]{0, }\n", "", res)
    res <- gsub("```", "", res)

  })

  output$usage <- renderText({
    req(openAI_response()$cmd)
    usage <- openAI_response()$response$usage

    paste0(
      "Tokens used: Input=",
      usage$prompt_tokens,
      ", Output=",
      usage$completion_tokens,
      ". \nCost=$", 
      sprintf("%f", usage$completion_tokens * 2e-5),
      "\nAPI time: ", 
      openAI_response()$time,
      " seconds."
    )

  })

  output$prompt_ChatGPT <- renderText({
    req(input$input_text)
    req(input$select_data)
    prep_input(input$input_text, input$select_data)
  })
  output$R_cmd <- renderText({
    req(openAI_response()$cmd)
    openAI_response()$cmd
  })

  output$result_plot <- renderPlot({
    req(openAI_response()$cmd)
    eval(parse(text = openAI_response()$cmd))
  })

  output$result_text <- renderText({
    req(openAI_response()$cmd)


    res <- capture.output(
      eval(
        parse(
          text = openAI_response()$cmd
        )
      )
    )
    paste(res, collapse = "\n")

  })

  output$results_ui <- renderUI({
    req(openAI_response()$cmd)

    # if the prompt include the "plot", generate a plot.
    # otherwise run statistical analysis.
    if(sum(grepl("plot|Plot|PLOT", openAI_response()$cmd)) > 0) {
      plotOutput("result_plot")
    } else {
      verbatimTextOutput("result_text")
    }
  })

  output$data_table <- renderTable({
    req(input$select_data)
    if(input$select_data == uploaded_data) {
      eval(parse(text = paste0("user_data()[1:20, ]")))
    } else {
      eval(parse(text = paste0(input$select_data, "[1:20, ]")))
    }
  },
  striped = TRUE,
  bordered = TRUE,
  hover = TRUE
  )
}

shinyApp(ui = ui, server = server)

# Run the application
# shiny::runApp("app.R")
