library(openai)
library(tidyverse)
library(shiny)

#' Move an element to the front of a vector
#'
#' The response from GPT3 sometimes contains strings that are not R commands.
#'
#' @param v is the vector
#' @param e is the element
#'
#' @return Returns a reordered vector
move_front <- function(v, e){
  ix <- which(v == e)

  # if found, move to the beginning.
  if(length(ix) != 0) {
    v <- v[-ix]
    v <- c(e, v)
  }
  return(v)
}


#' Prepare User input.
#'
#' The response from GPT3 sometimes contains strings that are not R commands.
#'
#' @param txt A string that stores the user input.
#' @param df Name of the dataset.
#'
#' @return Returns a cleaned up version, so that it could be sent to GPT.
prep_input <- function(txt, df){
  # if too short, do not send. 
  if(nchar(txt) < 10 || nchar(txt) > 500) {
    return(NULL)
  }
  txt <- paste("Generate R code, not R Markdown. ", txt)
  if(!is.null(df)) {
    txt <- paste("Use the", df, "dataset. ", txt)
  }


  # If the last character is not a stop, add it. 
  # Otherwise, GPT3 will add a sentence.

  # The following 5 lines were generated by ChatGPT!!!!!
  # Check if the last character is not a period
  if(substr(txt, nchar(txt), nchar(txt)) != "."){
    # If the last character is not a period, add a period to the end of the string
    txt <- paste(txt, ".", sep = "")
  }

  return(txt)
}


#' Clean up R commands generated by GTP
#'
#' The response from GTP3 sometimes contains strings that are not R commands.
#'
#' @param cmd A string that stores the completion from GTP3.
#'
#' @return Returns a cleaned up version, so that it could be executed as R command.
clean_cmd <- function(cmd){
  # simple way to check
  if(grepl("That model is currently overloaded with other requests.|Error:", cmd)) {
    return(NULL)
  }
  # Use cat to converts \n to newline
  # use capture.output to get the string
  cmd <- capture.output(
    cat(cmd)
  )
  # sometimes it returns RMarkdown code.
  cmd <- gsub("```", "", cmd)

  # replace install.packages by "#install.packages"
  cmd <- gsub("install.packages", "#install.packages", cmd)
  return(cmd)

}


###################################################################
# Prepare data
###################################################################
demos <- c(
  Boxplot = "Use ggplot2 to create a boxplot of hwy vs. class. Color by class.",
  ANOVA = "Conduct ANOVA of hwy by class.",
  Boxplot2 = "Use ggplot2 to create a boxplot of hwy vs. class.  Color by class.
Add jitter.
Remove x label.",
  ANOVA2 = "Conduct ANOVA of log-transformed hwy by class and drv.",
  Scatter = "Plot hwy vs. cty, colored by class. Change shape by drv.",
  Barplot = "Calculate average cty by year and class.
Then use ggplot2 to create a barplot of average mpg by class,
colored by year. The years should be side by side.",
  Analysis = "Calculate the correlation of cty vs hwy.
Repeat that after log transformation.
Collect these results and show them.",
Analysis2 = "Only keep cars with hwy bigger than 15, but less than 40.
Add 0.5 to cty.
Perform log transformation on cty.
Raise hwy to the second power.
Calculate correlation coefficient of transformed hwy and cty.",
Analysis_complex = "hwy and cty represent miles per gallon (MPG) on the highway and in the city, respectively.
Only keep cars more efficient than 15 MPG, but less than 40, on the highway.
Add 0.5 to city MPG for correction.
Perform log transformation on city MPG.
Raise highway MPG to the second power.
Calculate correlation coefficient of  the two transformed variables."
)

# prepare a list of available data sets.
datasets <- data()$results[, 3] # name of datasets
datasets <- gsub(" .*", "", datasets)
datasets <- move_front(datasets, "state.x77")
datasets <- move_front(datasets, "iris")
datasets <- move_front(datasets, "mpg")
datasets <- move_front(datasets, "mtcars")
datasets <- move_front(datasets, "diamonds")



###################################################################
# UI
###################################################################

ui <- fluidPage(
  titlePanel("Rtutor - Do statistics in English"),
  # Sidebar with a slider input for number of bins
  sidebarLayout(
    sidebarPanel(
        # Application title

      p(HTML("<div align=\"right\"> <A HREF=\"javascript:history.go(0)\">Reset</A></div>")),

      uiOutput("data_ui"),
      uiOutput("prompt_ui"),

      tags$style(type = "text/css", "textarea {width:100%}"),
      tags$textarea(
        id = "input_text",
        placeholder = NULL,
        rows = 8, ""
      ),
      actionButton("submit_button", strong("Submit")),
      br(), br(),
      verbatimTextOutput("usage"),
      h5("Personal project by",
        a("Xijin Ge.", href = "https://twitter.com/StevenXGe", target = "_blank"),
      "12/6/2022."),  
      h5("Powered by  OpenAI's", a("ChatGPT.", href = "https://openai.com/blog/chatgpt/", target = "_blank")),
    ),

    # Show a plot of the generated distribution
    mainPanel(
      verbatimTextOutput("openAI"),
      br(), br(),
      uiOutput("results_ui"),
      br(), br(),
      tableOutput("upload_data"),
      tableOutput("data_table")
    )
  )
  ,tags$head(includeScript("ga.js")) # tracking usage with Google analytics
)


###################################################################
# Server
###################################################################

server <- function(input, output, session) {
  # load demo data when clicked
  observe({
    req(input$demo_prompt)
    req(input$select_data)
    if(input$select_data == "mpg") {
      updateTextInput(
        session,
        "input_text",
        value = input$demo_prompt
      )
    } else { # if not mpg data, reset
      updateTextInput(
        session,
        "input_text",
        value = "",
        placeholder = 
"In one or more short sentences, clearly state the desired statistical analysis, step by step, in plain English, just like emailing a friend. Click the Re-submit button below if we do not get it correct."
      )
    }
  })

  observe({
    if (input$submit_button > 0) {
      updateTextInput(session, "submit_button", label = "Re-submit")
    }
  })


  user_data <- reactive({
    req(input$user_file)
    in_file_data <- input$user_data
    in_file_data <- in_file_data$datapath
    req(!is.null(in_file_data))
    
    isolate({
      # Read expression file -----------
      df <- read.csv(in_file_data, quote = "", comment.char = "")
      # Tab-delimented if not CSV
      if (ncol(df) <= 2) {
        df <- read.table(
          in_file_data,
          sep = "\t",
          header = TRUE,
          quote = "",
          comment.char = ""
        )
      }

      return(df)
    })
  })

  output$data_ui <- renderUI({
    # Hide this input box after the first run.
    req(input$submit_button == 0)

    tagList(
#      fileInput(
#        inputId = "user_file",
#        label = strong("Upload data (CSV or text)"),
#        accept = c(
#          "text/csv",
#          "text/comma-separated-values",
#          "text/tab-separated-values",
#          "text/plain",
#          ".csv",
#          ".tsv"
#        )
#      ),
      selectInput(
        inputId = "select_data",
        label = "Demo Datasets:",
        choices = datasets,
        selected = "mpg",
        multiple = FALSE,
        selectize = FALSE
      )
    )
  })

  output$prompt_ui <- renderUI({
    req(input$select_data)
    if(input$select_data == "mpg") {
      selectInput(
        inputId = "demo_prompt",
        choices = demos,
        label = "Example requests:"
      )
    } else {
      return(NULL)
    }
  })

  openAI_response <- reactive({

    req(input$submit_button)
    req(input$select_data)

    isolate({  # so that it will not responde to text, until submitted
      req(input$input_text)
      prepared_request <- prep_input(input$input_text, input$select_data)
      req(prepared_request)

      withProgress(message = "Thinking ... (About 1 min)", value = 0, {
        incProgress(0.7)

        start_time <- Sys.time()
        # Send to openAI
        response <- create_completion(
          engine_id = "text-davinci-003",
          prompt = prepared_request,
          openai_api_key = Sys.getenv("OPEN_API_KEY"),
          max_tokens = 500
        )
        api_time <- difftime(
          Sys.time(),
          start_time, 
          units = "secs"
        )[[1]] 
        #issue: check status

        cmd <- clean_cmd(response$choices[1, 1])

        return(
          list(
            cmd = cmd,
            response = response,
            time = round(api_time, 0)
          )
        )
      })
    })
  })

  output$openAI <- renderText({
    req(openAI_response()$cmd)
    res <- openAI_response()$response$choices[1, 1]
    # Replace multiple newlines with just one.
    res <- gsub("\n+", "\n", res)
    # Replace emplty lines,  [ ]{0, }--> zero or more space
    res <- gsub("^[ ]{0, }\n", "", res)
    res <- gsub("```", "", res)

  })

  output$usage <- renderText({
    req(openAI_response()$cmd)
    usage <- openAI_response()$response$usage

    paste0(
      "Tokens used: Input=",
      usage$prompt_tokens,
      ", Output=",
      usage$completion_tokens,
      ". \nCost=$", 
      sprintf("%f", usage$completion_tokens * 2e-5),
      "\nAPI time: ", 
      openAI_response()$time,
      " seconds."
    )

  })

  output$result_plot <- renderPlot({
    req(openAI_response()$cmd)
    eval(parse(text = openAI_response()$cmd))
  })

  output$result_text <- renderText({
    req(openAI_response()$cmd)


    res <- capture.output(
      eval(
        parse(
          text = openAI_response()$cmd
        )
      )
    )
    paste(res, collapse = "\n")

  })

  output$results_ui <- renderUI({
    req(openAI_response()$cmd)

    # if the prompt include the "plot", generate a plot.
    # otherwise run statistical analysis.
    if(sum(grepl("plot|Plot|PLOT", openAI_response()$cmd)) > 0) {
      plotOutput("result_plot")
    } else {
      verbatimTextOutput("result_text")
    }
  })

  output$data_table <- renderTable({
    req(input$select_data)
    eval(parse(text = paste0(input$select_data, "[1:20, ]")))
  },
  striped = TRUE,
  bordered = TRUE,
  hover = TRUE
  )
  output$upload_data <- renderTable({
    req(input$user_file)
    req(user_data())
    user_data()[1:20, ]
  },
  striped = TRUE,
  bordered = TRUE,
  hover = TRUE
  )

}

shinyApp(ui = ui, server = server)

# Run the application
# shiny::runApp("app.R")
